#+title: Parsing markdown with functions (with F#)
#+subtitle: An F# introduction
#+author: @paudirac
#+email: pau.cervera@gmail.com

#+REVEAL_ROOT: https://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_EXTRA_CSS: ./css/stylesheet.css

#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+OPTIONS: reveal_title_slide:nil

#+MACRO: color @@html:<font color="$1">$2</font>@@


* Parsing markdown with functions
  :PROPERTIES:
  :reveal_background: http://fsharp.org/img/logo/fsharp256.png
  :END:

  *Introducing F#*

* 
  :PROPERTIES:
  :reveal_background: ./images/threadless.jpg
  :END:

* About me

  #+ATTR_REVEAL: :frag (appear)
  - I'm [[https://twitter.com/paudirac][@paudirac]]
  - I'm working at [[https://twitter.com/capside][@capside]]
  - I usually rant about Perl
  - I usually praise about functional programming
  - my knowledge of football reduces to: =I think there's a spherical ball=
  - soâ€¦, probably I meant soccer

* {{{color(black, Intent)}}}
  :PROPERTIES:
  :reveal_background_transition: zoom
  :reveal_background: ./images/inception.jpg
  :END:

  #+ATTR_REVEAL: :frag (appear)
  {{{color(gray, trying to transmit why I love the FP approach)}}}

* 
  :PROPERTIES:
  :reveal_background_transition: zoom
  :reveal_background: ./images/inception.jpg
  :END:

  #+begin_src basic :eval never
  REM outline
  NEW
  30 PRINT "building a parser/translator with functions"
  10 PRINT "building blocks"
  40 GOTO 90
  50 LET MEANING = 40 + 2
  90 PRINT "building a parser/compiler with functions and types"
  #+end_src

** 
  :PROPERTIES:
  :reveal_background_transition: zoom
  :reveal_background: ./images/inception.jpg
  :END:

   #+begin_src fsharp :eval never
   buildingBlocks |> buildingAParser |> buildingACompiler
   #+end_src

* building blocks (types)
  :PROPERTIES:
  :reveal_background: ./images/building-blocks.jpg
  :END:
  (introducing f#)

** (simple) types
  :PROPERTIES:
  :reveal_background: ./images/building-blocks.jpg
  :END:
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >42;;
   val it : int = 42
   #+end_src
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >"The meaning of life is %d";;
   val it : string = "The meaning of life is %d"
   #+end_src


** function types
  :PROPERTIES:
  :reveal_background: ./images/building-blocks.jpg
  :END:
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >sprintf "The meaning of life is %d";;
   val it : (int -> string)
   #+end_src


** function application 
  :PROPERTIES:
  :reveal_background: ./images/building-blocks.jpg
  :END:

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >sprintf "The meaning of life is %d" 42;;
   val it : string = "The meaning of life is 42"
   #+end_src

** let 
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >let life = 42;;
   val life : int = 42
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >let meaning = sprintf "The meaning of life is %d";;
   val meaning : (int -> string)
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   or 
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >let meaning i = sprintf "The meaning of life is %d" i;;
   val meaning : i:int -> string
   #+end_src

** function application (revisited)
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >meaning life;;
   val it : string = "The meaning of life is 42"
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >life |> meaning;;
   val it : string = "The meaning of life is 42"
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >meaning <| 40 + 2;;
   val it : string = "The meaning of life is 42"
   #+end_src


* Parsing a char

  #+ATTR_REVEAL: :frag (appear)
  We would like to parse the character ~a~.
  
** Design
   
   #+ATTR_REVEAL: :frag (appear)
   The parser of =a= is a function that, given an input string
   =s=:

   #+ATTR_REVEAL: :frag (appear)
   - succeds parsing =a=
   - or fails parsing =a=

** REPL time 
** 
   #+begin_src fsharp :eval never
   
type Parsed =
    | Success of string * string
    | Failure of string

   #+end_src

** pChar
   #+begin_src fsharp :eval never
   
let pChar c =
    function (s:string) -> let f = s.[0]
                           if f = c then Success (stringify c, s.[1..])
                           else Failure s

   #+end_src

** Implemenentation #1

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   
let stringify x = x.ToString();

type Parsed =
    | Success of string * string
    | Failure of string

let pChar c =
    function (s:string) -> let f = s.[0]
                           if f = c then Success (stringify c, s.[1..])
                           else Failure s

   #+end_src

** Demo

#+BEGIN_NOTES
On the repl, try:
(parse-a "hello")
(parse-a "ahello")
#+END_NOTES
