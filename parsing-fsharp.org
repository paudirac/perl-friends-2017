#+title: Parsing markdown with functions (with F#)
#+subtitle: An F# introduction
#+author: @paudirac
#+email: pau.cervera@gmail.com

#+REVEAL_ROOT: https://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_EXTRA_CSS: ./css/stylesheet.css
# #+REVEAL_THEME: white

#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+OPTIONS: reveal_title_slide:nil

#+MACRO: color @@html:<font color="$1">$2</font>@@


* Parsing markdown with functions

  *Introducing F#*

* About me
  :PROPERTIES:
  :reveal_background_transition: zoom
  :reveal_background: ./images/fullerene.png
  :END:

  #+ATTR_REVEAL: :frag (appear)
  - I'm [[https://twitter.com/paudirac][@paudirac]]
  - I'm working at [[https://twitter.com/capside][@capside]]
  - I usually rant about Perl
  - I usually praise about functional programming
  - my knowledge of football reduces to: =I think there's a spherical ball=
  - soâ€¦, probably I meant soccer

* 

* 
  :PROPERTIES:
  :reveal_background: ./images/pills2.jpg
  :END:

  #+ATTR_REVEAL: :frag (appear)
  #+begin_src basic :eval never
  REM outline
  NEW
  30 PRINT "building a parser/translator with functions"
  10 PRINT "building blocks"
  40 GOTO 90
  50 LET MEANING = 40 + 2
  90 PRINT "building a parser/compiler with functions and types"
  #+end_src

** 
  :PROPERTIES:
  :reveal_background: ./images/pills2.jpg
  :END:

   #+begin_src fsharp :eval never
   buildingBlocks |> buildingAParser |> buildingACompiler
   #+end_src

* building blocks (types)
  :PROPERTIES:
  :reveal_background: ./images/building-blocks-free.png
  :END:
  (introducing f#)

** (simple) types
  :PROPERTIES:
  :reveal_background: ./images/building-blocks-free.png
  :END:
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >42;;
   val it : int = 42
   #+end_src
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >"The meaning of life is %d";;
   val it : string = "The meaning of life is %d"
   #+end_src


** function types
  :PROPERTIES:
  :reveal_background: ./images/building-blocks-free.png
  :END:
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >sprintf "The meaning of life is %d";;
   val it : (int -> string)
   #+end_src


** function application 
  :PROPERTIES:
  :reveal_background: ./images/building-blocks-free.png
  :END:

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >sprintf "The meaning of life is %d" 42;;
   val it : string = "The meaning of life is 42"
   #+end_src

** let 
  :PROPERTIES:
  :reveal_background: ./images/ET_Moon.jpg
  :END:
  
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >let life = 42;;
   val life : int = 42
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >let meaning = sprintf "The meaning of life is %d";;
   val meaning : (int -> string)
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   or 
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >let meaning i = sprintf "The meaning of life is %d" i;;
   val meaning : i:int -> string
   #+end_src

** function application (revisited)
  :PROPERTIES:
  :reveal_background: ./images/ET_Moon.jpg
  :END:

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >meaning life;;
   val it : string = "The meaning of life is 42"
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >life |> meaning;;
   val it : string = "The meaning of life is 42"
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >meaning <| 40 + 2;;
   val it : string = "The meaning of life is 42"
   #+end_src


* Parsing a char
  :PROPERTIES:
  :reveal_background: ./images/refraction.jpg
  :END:

  #+ATTR_REVEAL: :frag (appear)
  We would like to parse the character ~a~.
  
** Design
   :PROPERTIES:
   :reveal_background: ./images/refraction.jpg
   :END:
  
   #+ATTR_REVEAL: :frag (appear)
   The parser of =a= is a function that, given an input string
   =s=:

   #+ATTR_REVEAL: :frag (appear)
   - succeds parsing =a=
   - or fails parsing =a=

* REPL time 
  :PROPERTIES:
  :reveal_background: ./images/inception-free.jpg
  :END:

** 
  :PROPERTIES:
  :reveal_background: ./images/inception-free.jpg
  :END:


   #+begin_src fsharp :eval never
   
type Parsed =
    | Success of string * string
    | Failure of string

   #+end_src

** pChar
  :PROPERTIES:
  :reveal_background: ./images/inception-free.jpg
  :END:


   #+begin_src fsharp :eval never
   
let pChar c =
    function (s:string) -> let f = s.[0]
                           if f = c then Success (stringify c, s.[1..])
                           else Failure s

   #+end_src

** Recap
  :PROPERTIES:
  :reveal_background: ./images/monolith-apes.jpg
  :END:

   #+begin_src fsharp :eval never
   
let stringify x = x.ToString();

type Parsed =
    | Success of string * string
    | Failure of string

let pChar c =
    function (s:string) -> let f = s.[0]
                           if f = c then Success (stringify c, s.[1..])
                           else Failure s

   #+end_src

* parsing two chars 
  
  #+ATTR_REVEAL: :frag (appear)
  The parser of =ab= is a function that, given an input string
  =s=:

  #+ATTR_REVEAL: :frag (appear)
   - succeds parsing =ab=
   - or fails parsing =ab=

** generalize 

  #+ATTR_REVEAL: :frag (appear)
  The would like a function that, given two parsers =p1= and =p2=
  will return a parser that, given an input string
  =s=:

  #+ATTR_REVEAL: :frag (appear)
   - will succeds parsing what =p1= parses and parsing what =p2= parses
   - or fails parsing

** 
   #+begin_src fsharp :eval never
let pAnd p1 p2 =
    function (s:string) -> match p1 s with
                  | Failure f -> Failure f
                  | Success (f,r) -> match p2 r with
                                     | Success (f2, r2) -> Success (f + f2, r2)
                                     | _ -> Failure f
   #+end_src

   #+begin_src fsharp :eval never
val pAnd : p1:(string -> Parsed) -> p2:(string -> Parsed) -> _arg1:string -> Parsed
   #+end_src

** 
   #+begin_src fsharp :eval never
let pA = pChar 'a'
let pB = pChar 'b'
let pAB = pAnd pA pB
   #+end_src

** expressivity
   #+begin_src fsharp :eval never
let (<&>) p1 p2 = pAnd p1 p2
let pAB = pA <&> pB
   #+end_src


* pSeq

** recursive

   #+begin_src fsharp :eval never
let pSeq ps =
    let plist = ps |> Seq.toList
    function s ->
        let rec parse parsers acc rest =
            match parsers with
            | [] -> Success (acc, rest)
            | p::ps' -> let r = p rest
                        match r with
                        | Success (a, b) -> parse ps' (acc + a) b
                        | Failure f -> r
        parse plist "" s
   #+end_src

** generalize

   From the docs:
   #+begin_src fsharp :eval never
Seq.fold : ('State -> 'T -> 'State) -> 'State -> seq<'T> -> 'State
   #+end_src

   in our case ``State` is `Parser` and `T` is `Parser` also.

   pDot is unit?
   Example with unit

   #+begin_src fsharp :eval never
let pDot = 
    function s -> match explode s with
                    | [] -> Failure s
                    | c::cs -> Success (implode [c], implode cs)

let pSeq' ps = 
    let sp = ps |> Array.ofSeq |> Array.rev
    let folder acc curr = pAnd curr acc
    in Seq.fold folder pDot sp
   #+end_src

** Recap 
  :PROPERTIES:
  :reveal_background: ./images/monolith-moon.jpg
  :END:

   #+begin_src fsharp :eval never
let pSeq' ps = 
    let sp = ps |> Array.ofSeq |> Array.rev
    let folder acc curr = pAnd curr acc
    in Seq.fold folder pDot sp
   #+end_src

** bind

   #+begin_src fsharp :eval never
let pBind p f =
    function s -> match p s with
                    | Success (s', r) -> let p' = f s' in p' r
                    | _ -> Failure s

let (>>=) p f = pBind p f

let succeed v = function s -> Success(v, s)

   #+end_src

** 

   #+begin_src fsharp :eval never
> let pA = pChar 'a';;
val pA : (string -> Parsed)
> let pB = pChar 'b';;
val pB : (string -> Parsed)
> pA >>= (fun s -> pB);;
val it : (string -> Parsed)
> (pA >>= (fun s -> pB)) "abcde";;
val it : Parsed = Success ("b","cde")
> (pA >>= (fun a -> pB >>= (fun b -> succeed (a + b)))) "abcde";;
val it : Parsed = Success ("ab","cde")
   #+end_src

** 

   #+begin_src fsharp :eval never
> (pA >>= fun a ->
-            pB >>= fun b ->
-                       succeed (a + b)) "abcdef";;
val it : Parsed = Success ("ab","cdef")
   #+end_src

   #+begin_src fsharp :eval never
> let abc = a >>= fun a' -> b >>= fun b' -> c >>= fun c' -> succeed (a' + b' + c');;
val abc : (string -> Parsed)
> abc "abcdef";;
val it : Parsed = Success ("abc","def")
   #+end_src
