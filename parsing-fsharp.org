#+title: Parsing markdown with functions (with F#)
#+subtitle: An F# introduction
#+author: @paudirac
#+email: pau.cervera@gmail.com

#+REVEAL_ROOT: https://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_EXTRA_CSS: ./css/stylesheet.css
# #+REVEAL_THEME: white

#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+OPTIONS: reveal_title_slide:nil

#+MACRO: color @@html:<font color="$1">$2</font>@@


* Parsing markdown with functions
  :PROPERTIES:
  :reveal_background: http://fsharp.org/img/logo/fsharp256.png
  :END:

  *Introducing F#*

* 
  :PROPERTIES:
  :reveal_background: ./images/threadless.jpg
  :END:

* About me

  #+ATTR_REVEAL: :frag (appear)
  - I'm [[https://twitter.com/paudirac][@paudirac]]
  - I'm working at [[https://twitter.com/capside][@capside]]
  - I usually rant about Perl
  - I usually praise about functional programming
  - my knowledge of football reduces to: =I think there's a spherical ball=
  - soâ€¦, probably I meant soccer

* intent
  :PROPERTIES:
  :reveal_background_transition: zoom
  :reveal_background: ./images/inception.jpg
  :END:

  #+ATTR_REVEAL: :frag (appear)
  trying to transmit why I love the FP approach

* 
  :PROPERTIES:
  :reveal_background_transition: zoom
  :reveal_background: ./images/inception.jpg
  :END:

  #+begin_src basic :eval never
  REM outline
  NEW
  30 PRINT "building a parser/translator with functions"
  10 PRINT "building blocks"
  40 GOTO 90
  50 LET MEANING = 40 + 2
  90 PRINT "building a parser/compiler with functions and types"
  #+end_src

** 
  :PROPERTIES:
  :reveal_background_transition: zoom
  :reveal_background: ./images/inception.jpg
  :END:

   #+begin_src fsharp :eval never
   buildingBlocks |> buildingAParser |> buildingACompiler
   #+end_src

* building blocks (types)
  :PROPERTIES:
  :reveal_background: ./images/building-blocks.jpg
  :END:
  (introducing f#)

** (simple) types
  :PROPERTIES:
  :reveal_background: ./images/building-blocks.jpg
  :END:
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >42;;
   val it : int = 42
   #+end_src
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >"The meaning of life is %d";;
   val it : string = "The meaning of life is %d"
   #+end_src


** function types
  :PROPERTIES:
  :reveal_background: ./images/building-blocks.jpg
  :END:
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >sprintf "The meaning of life is %d";;
   val it : (int -> string)
   #+end_src


** function application 
  :PROPERTIES:
  :reveal_background: ./images/building-blocks.jpg
  :END:

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >sprintf "The meaning of life is %d" 42;;
   val it : string = "The meaning of life is 42"
   #+end_src

** let 
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >let life = 42;;
   val life : int = 42
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >let meaning = sprintf "The meaning of life is %d";;
   val meaning : (int -> string)
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   or 
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >let meaning i = sprintf "The meaning of life is %d" i;;
   val meaning : i:int -> string
   #+end_src

** function application (revisited)
   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >meaning life;;
   val it : string = "The meaning of life is 42"
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >life |> meaning;;
   val it : string = "The meaning of life is 42"
   #+end_src

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   >meaning <| 40 + 2;;
   val it : string = "The meaning of life is 42"
   #+end_src


* Parsing a char

  #+ATTR_REVEAL: :frag (appear)
  We would like to parse the character ~a~.
  
** Design
   
   #+ATTR_REVEAL: :frag (appear)
   The parser of =a= is a function that, given an input string
   =s=:

   #+ATTR_REVEAL: :frag (appear)
   - succeds parsing =a=
   - or fails parsing =a=

** REPL time 
** 
   #+begin_src fsharp :eval never
   
type Parsed =
    | Success of string * string
    | Failure of string

   #+end_src

** pChar
   #+begin_src fsharp :eval never
   
let pChar c =
    function (s:string) -> let f = s.[0]
                           if f = c then Success (stringify c, s.[1..])
                           else Failure s

   #+end_src

** Recap

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src fsharp :eval never
   
let stringify x = x.ToString();

type Parsed =
    | Success of string * string
    | Failure of string

let pChar c =
    function (s:string) -> let f = s.[0]
                           if f = c then Success (stringify c, s.[1..])
                           else Failure s

   #+end_src

** Demo

#+BEGIN_NOTES
On the repl, try:
(parse-a "hello")
(parse-a "ahello")
#+END_NOTES

* parsing two chars 
  
  #+ATTR_REVEAL: :frag (appear)
  The parser of =ab= is a function that, given an input string
  =s=:

  #+ATTR_REVEAL: :frag (appear)
   - succeds parsing =ab=
   - or fails parsing =ab=

** generalize 

  #+ATTR_REVEAL: :frag (appear)
  The would like a function that, given two parsers =p1= and =p2=
  will return a parser that, given an input string
  =s=:

  #+ATTR_REVEAL: :frag (appear)
   - will succeds parsing what =p1= parses and parsing what =p2= parses
   - or fails parsing

** 
   #+begin_src fsharp :eval never
let pAnd p1 p2 =
    function (s:string) -> match p1 s with
                  | Failure f -> Failure f
                  | Success (f,r) -> match p2 r with
                                     | Success (f2, r2) -> Success (f + f2, r2)
                                     | _ -> Failure f
   #+end_src

   #+begin_src fsharp :eval never
val pAnd : p1:(string -> Parsed) -> p2:(string -> Parsed) -> _arg1:string -> Parsed
   #+end_src

** 
   #+begin_src fsharp :eval never
let pA = pChar 'a'
let pB = pChar 'b'
let pAB = pAnd pA pB
   #+end_src

** expressivity
   #+begin_src fsharp :eval never
let (<&>) p1 p2 = pAnd p1 p2
let pAB = pA <&> pB
   #+end_src


